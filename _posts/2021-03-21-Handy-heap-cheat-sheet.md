---
layout:     post
title:      "如何手撕一个堆"
subtitle:   "如果哪一天你把编程语言的类库全忘光了，又遇到一题明知到要用堆的题目，咋办？对着一道自己明显会的题干着急,愣是想不起PriorityQueue的名字。这时候只能自己实现一个堆出来了。"
date:       2021-08-28 23:09:14
author:     "Ryo"
header-img: "img/post-bg-default.jpg"
tags:
    - 数据结构
    - 算法
    - 算法竞赛
---

# 如何手撕一个堆

# 写在前面

在参加如AtCoder等算法竞技，或是刷Leetcode等算法题时，我们总是不可避免地遇到堆这种数据结构。

当然，一般来说我们只要理解堆，知道堆的性质，知道怎么样用堆就足够了。在做题时只需要调用系统类库即可——在参加AtCoder时你甚至不会有时间去自己实现一个堆。

但是，如果哪一天你把编程语言的类库全忘光了，又遇到一题需要频繁求最值的题目——你明知这里要用堆，却又忘记该调用的类名了，咋办？我还真遇到过这问题：三年没刷算法，只能对着一道自己明显会的题干着急，愣是想不起PriorityQueue的名字。这时候，只能自己实现一个堆出来了。

# 目录

# 首先要理解，然后才能实现

就像人总不会忘记自行车怎么骑一样，只要理解了数据结构的原理，身体就会自动来帮我们记忆，总不会忘。那要怎么理解一个堆呢？

## 先抓住重点：堆是一种树结构

首先最重要的，要理解堆是一种树结构。不管实际是基于数组实现还是别的什么实现，逻辑结构是树结构没变的。

再进一步，在堆这种树结构中，最重要的约束就是：**对于树中的每个节点，总有父节点大于两个子节点**（以大顶堆为例，下同）。

如此一来，大小关系在树中层层传递，最终可得树的根节点（堆顶）就是整个堆的最大节点，读取堆中最大值的时间复杂度为O(1)。而我们使用堆也一般是为了利用这种堆顶元素就是最大值的特点，读取、删除操作一般会限制为只允许读取、删除堆顶元素。

而且我们可以注意到，与二叉查找树比起来，堆的约束十分之弱：堆只约束父节点与子节点的大小关系，而不需要管左右子树的大小关系，甚至不需要管左右两个子节点之间谁大谁小。这样一来堆就有很多很好的性质了：

1. 堆并不关注左右子树之间的大小情况，那么**要维护一个堆，基本只需要做交换父节点与子节点的操作**，而不需要像二叉查找树那样做各种旋转操作。
2. 因为维护一个堆不需要做旋转操作，那么几乎不需要花任何代价，就可以把堆的树结构维持在完全二叉树状态。因此堆的物理结构可以设计得很紧凑，**可以使用数组进行实现**。
3. 因为堆可以维持在完全二叉树状态，那么堆的树结构的高度就可以控制为O(logn)范围内。而如上所述，要维护一个堆我们不需要关注左右子树的关系。因此我们要在堆上做增删操作，都只需要上下交换若干次父子节点。而交换次数最多时，也只是从树根一直交换到树叶，或是从树叶一直交换到树根，最多交换logn次。那么我们可得：**堆的增删操作最坏时间复杂度为O(logn)**。

## 再抓基本操作：上浮与下沉

上面也提到，要维护一个堆，我们只需要上下交换若干次父子节点即可。若一个节点**过大**，就跟他的父节点**向上交换**；若一个节点**过小**，就跟他的子节点**向下交换**。

假设p节点破坏了堆结构，大于他的父节点g，向上交换如下图：

向上交换后有两个破坏堆结构的可能性：

1. p节点破坏堆结构，大于g的父节点gg
2. g节点破坏堆结构，小于p的一个子节点c

若原先除了p节点外其他所有节点都符合堆结构，则总有g节点大于c节点。因此向上交换后只有p节点有可能继续破坏堆结构。而解决方法也很简单，就是递归地进行向上交换，最坏情况下一直交换到堆根节点为止。

同理可得，p节点小于他的子节点时，向下交换后有可能需要递归地向下交换，最坏情况下一直交换到叶子节点为止。要注意向下交换时需要先比较一下两个子节点的大小，再跟较大的子节点交换，才能交换后的大小关系符合堆的要求。

为了简化，我们把前面那种递归地向上交换称为**上浮操作**，把后面这种递归地向下交换称为**下沉操作**。所有需要维护堆结构的操作：增、删、建堆，都可以拆分为上浮操作或是下沉操作的组合。

# 各种接口的逻辑

## 插入元素——入堆

把一个元素p加入堆中，我们可以先把p加到堆尾，然后对p做上浮操作。

虽然堆是一个树结构，但由于堆可以用数组实现，那我们只要用O(1)的时间就可以找到堆尾。而如上面所述上浮操作最多交换到根节点 。由于用数组实现的堆是完全二叉树，交换到根节点时间复杂度为O(logn)。因此我们可得入堆的最坏时间复杂度为O(logn)。

## 删除堆顶元素——出堆

我们从堆中删除元素时，一般只会删除堆顶元素。

删除堆顶元素时，我们可以摘出堆尾元素p填到堆顶的空缺中，再对p做下沉操作。找到堆尾元素需要O(1)时间，下沉操作最多交换到叶子节点，时间复杂度为O(logn)。因此出堆最坏时间复杂度为O(logn)。

这里加点餐：出堆时把堆尾元素p放到堆顶后下沉，而p原先在堆中的最下层，一般在整个堆中都算较小的元素。因此下沉p时有较大概率需要一直把p下沉到最下层或是倒数第二层，即出堆时最坏情况出现概率较高。

## 堆的初始化——建堆

建立一个堆，我们有两种思路：

1. 将元素一个一个插入，即对每个元素都做一次入堆操作。
2. 当节点p左子树和右子树都各自为一个堆时，只要把p下沉就可以把左右两个堆合并成一个更大的堆。即不断地进行堆合并操作。

下面我们来分析这两种建堆策略。

### 元素逐个入堆

上面说到，入堆就是把元素加到堆尾，再做上浮操作。把元素逐个入堆，就是把元素逐个上浮。

插入第i个元素时，堆的大小为$i$（在不影响计算情况下的近似，下同），则有堆的高度为，则上浮时间复杂度为：

$$T(i) = logi$$

那么把所有元素上浮，则总时间复杂度为：

$$\begin{aligned}
T(n) &= \sum_{i=1}^{n}logi\\
&= 1\times0 + 2\times1 + ... + 2^{logn}\times{logn} \\
&=O(nlogn)
\end{aligned}$$

通过把元素逐个入堆来建堆时，元素的时间复杂度可以用下图直观显示：

（每条红线的长度就是插入该元素所需的时间，红线的总长度就是建堆所需的总时间复杂度）
